import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, classification_report

# --- Load your data ---
# Assuming your dataframe is already loaded into df_master_transaction
df = df_master_transaction.copy()

# Convert 'month_end_date' to datetime (if not already)
df['month_end_date'] = pd.to_datetime(df['month_end_date'], errors='coerce')

# Sort by user and date
df.sort_values(['ip_id', 'month_end_date'], inplace=True)
df.reset_index(drop=True, inplace=True)


# Identify columns for counts and amounts
count_cols = [col for col in df.columns 
              if col.startswith('num_') and col.endswith('_cnt_monthly_sum')]
amount_cols = [col for col in df.columns if col.endswith('_amt_monthly_sum')]

# Create a total transaction count and total transaction amount
df['total_count'] = df[count_cols].sum(axis=1)
df['total_amount'] = df[amount_cols].sum(axis=1)


def add_lag_and_pct_change(df, group_col, date_col, col, lag=1):
    """
    For each user (group_col), create a lag feature of `col` and a percentage change vs. that lag.
    """
    df[f'lag_{col}'] = df.groupby(group_col)[col].shift(lag)
    df[f'{col}_pct_change'] = (
        (df[col] - df[f'lag_{col}']) / df[f'lag_{col}']
    ).replace([np.inf, -np.inf], np.nan)
    return df

def add_rolling_recovery(df, group_col, col, window=3):
    """
    For each user, check if the metric recovers within the next 'window' months.
    'Recovery' means the value returns to or exceeds the prior month's value.
    """
    def rolling_max_next_n(series):
        # Shift by -1 to start looking at the "next" month
        # Then rolling() over 'window' to find max in next 'window' months
        return series.shift(-1).rolling(window=window, min_periods=1).max()
    
    # Compute the rolling max over the next 'window' months
    df[f'{col}_max_next_{window}'] = df.groupby(group_col)[col].transform(rolling_max_next_n)
    
    # We define "recovered" if the max in the next N months >= last month's value
    # But we must compare to the 'lag_{col}' so we know the previous month's value
    df[f'{col}_recovered'] = (
        df[f'{col}_max_next_{window}'] >= df[f'lag_{col}']
    )
    
    return df


# ACH Incoming Count
col_ach_count = 'num_ach_incoming_cnt_monthly_sum'

df = add_lag_and_pct_change(df, group_col='ip_id', date_col='month_end_date', col=col_ach_count)
df = add_rolling_recovery(df, group_col='ip_id', col=col_ach_count, window=3)

# Rule: Drop >= 50% and no recovery
df['rule_ach_drop'] = (
    (df[f'{col_ach_count}_pct_change'] <= -0.50) &
    (df[f'{col_ach_count}_recovered'] == False)
).astype(int)


col_total_count = 'total_count'

df = add_lag_and_pct_change(df, group_col='ip_id', date_col='month_end_date', col=col_total_count)
df = add_rolling_recovery(df, group_col='ip_id', col=col_total_count, window=3)

# Rule: Drop >= 40% and no recovery
df['rule_total_count_drop'] = (
    (df[f'{col_total_count}_pct_change'] <= -0.40) &
    (df[f'{col_total_count}_recovered'] == False)
).astype(int)


# If you have a column for Zelle credit counts
col_zelle_credit = 'num_zelle_credit_monthly_sum'  # adjust if needed

df = add_lag_and_pct_change(df, group_col='ip_id', date_col='month_end_date', col=col_zelle_credit)
df = add_rolling_recovery(df, group_col='ip_id', col=col_zelle_credit, window=3)

df['rule_zelle_drop'] = (
    (df[f'{col_zelle_credit}_pct_change'] <= -0.40) &
    (df[f'{col_zelle_credit}_recovered'] == False)
).astype(int)


df['attrition_alert'] = (
    (df['rule_ach_drop'] == 1) |
    (df['rule_total_count_drop'] == 1) |
    (df['rule_zelle_drop'] == 1)
).astype(int)




# Confusion Matrix
cm = confusion_matrix(df['attrition_label'], df['attrition_alert'])
print("Confusion Matrix:\n", cm)

# Classification Report (precision, recall, F1)
report = classification_report(df['attrition_label'], df['attrition_alert'])
print("\nClassification Report:\n", report)


grouped = df.groupby('attrition_label')[
    [f'{col_ach_count}_pct_change',
     f'{col_total_count}_pct_change',
     f'{col_zelle_credit}_pct_change']
].mean()

print("Average % Change by Attrition Label:\n", grouped)


sample_user = df['ip_id'].iloc[0]  # pick one user ID
user_df = df[df['ip_id'] == sample_user]

plt.figure(figsize=(10,5))
plt.plot(user_df['month_end_date'], user_df[col_ach_count], marker='o', label='ACH Incoming Count')
plt.title(f'ACH Incoming Transactions Over Time for User {sample_user}')
plt.xlabel('Month')
plt.ylabel('ACH Incoming Count')
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()

