from pyspark.sql.functions import col, mean, max, min, when, to_date, datediff
from datetime import datetime, timedelta

def calculate_balance_stats(spark, cfg, prev_dt, latest_dt):
    # Get master data
    df = get_master_data(spark, cfg)

    # Convert prev_dt and latest_dt to Python datetime objects
    start_date = datetime.strptime(prev_dt, "%Y-%m-%d")
    end_date = datetime.strptime(latest_dt, "%Y-%m-%d")

    # Initialize an empty DataFrame to store results
    final_df = None

    # Iterate through each date in the range
    current_date = start_date
    while current_date <= end_date:
        current_date_str = current_date.strftime("%Y-%m-%d")

        # Filter for the current business_date
        filtered_df = df.filter(col("business_date") == current_date_str)

        # Skip if no data exists for the current date
        if filtered_df.count() == 0:
            current_date += timedelta(days=1)
            continue

        # Calculate days_diff
        filtered_df = filtered_df.withColumn("days_diff", datediff(to_date(col("business_date")), to_date(col("open_date"))))

        # Filter data for different time ranges and calculate statistics
        stats_df = (
            filtered_df.groupBy("segmt_prod_type", "business_date")
            .agg(
                # Calculate mean, max, min for 1 month
                mean(when((col("days_diff") <= 30) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("mean_balance_1m"),
                max(when((col("days_diff") <= 30) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("max_balance_1m"),
                min(when((col("days_diff") <= 30) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("min_balance_1m"),

                # Calculate mean, max, min for 2 months
                mean(when((col("days_diff") <= 60) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("mean_balance_2m"),
                max(when((col("days_diff") <= 60) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("max_balance_2m"),
                min(when((col("days_diff") <= 60) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("min_balance_2m"),

                # Calculate mean, max, min for 6 months
                mean(when((col("days_diff") <= 180) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("mean_balance_6m"),
                max(when((col("days_diff") <= 180) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("max_balance_6m"),
                min(when((col("days_diff") <= 180) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("min_balance_6m"),

                # Calculate mean, max, min for 12 months
                mean(when((col("days_diff") <= 365) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("mean_balance_12m"),
                max(when((col("days_diff") <= 365) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("max_balance_12m"),
                min(when((col("days_diff") <= 365) & (col("days_diff") >= 0), col("curr_bal_amt"))).alias("min_balance_12m")
            )
        )

        # Union the result with the final DataFrame
        if final_df is None:
            final_df = stats_df
        else:
            final_df = final_df.union(stats_df)

        # Move to the next date
        current_date += timedelta(days=1)

    # Return the final DataFrame
    return final_df




