# credit_card.py (inside src/fraud_origination/customer_score/cs_v2/data)
from pyspark.sql import SparkSession, DataFrame, functions as F
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from functools import reduce

from fraud_origination.customer_score.cs_v2.data_dev.features.training_data_utils import get_pop_accounts


def cc_account_history(
    spark: SparkSession,
    first_date: str,
    last_date: str,
    acct_df: Union[DataFrame, None] = None
) -> DataFrame:
    """
    Returns the raw CC account history between first_date and last_date (inclusive),
    filtered to product = 'CC' and extracting the last-9 digits for joining.
    """
    # load and filter am04
    df_am04 = (
        spark.table("s11_cp_cnsum.am04_P_h")
             .filter(F.col("ods_business_dt").between(first_date, last_date))
             .filter(F.col("prodcode") == "CC")
             # only consumer cards: first char 'C'
             .filter(F.substring(F.col("account_num"), 1, 1) == "C")
             .select(
                 F.col("gsam_appl_num").cast("bigint").alias("account_num"),
                 "ods_business_dt",
                 "am04_date_most_recent_pd",
                 "am04_amt_most_recent_pd",
                 "am04_date_high_balance_pastdue",
                 "am04_balance_high_pastdue",
                 "am04_cons_days_pastdue"
             )
    )

    df_am02 = (
        spark.table("s11_cp_cnsum.am02_h")
             .filter(F.col("ods_business_dt").between(first_date, last_date))
             .filter(F.col("prodcode") == "CC")
             .filter(F.substring(F.col("account_num"), 1, 1) == "C")
             .select(
                 F.col("gsam_appl_num").cast("bigint").alias("account_num"),
                 "ods_business_dt",
                 "am02_date_potential_chargeoff",
                 "am02_balance_prev_statement",
                 "am02_date_chargeoff_reinstated",
                 "am02_balance_current",
                 "am02_balance_high_ltd",
                 "am02_date_first_use",
                 "am02_num_lte_fee_since_lst_cur",
                 "am02_num_ol_fee_lst_w_in_limit",
                 "am02_amt_last_nsf_payment",
                 "am02_date_last_nsf_payment",
                 "am02_num_nsf_payments_ltd",
                 "am02_date_last_paid_balance",
                 "am02_date_last_payment",
                 "am02_amt_ptp_broken_ltd",
                 "am02_num_ptp_broken_ltd",
                 "am02_amt_ptp_kept_ltd",
                 "am02_num_ptp_kept_ltd",
                 "am02_amt_ptp_partial_ltd",
                 "am02_num_ptp_partial_ltd",
                 "am02_mths_consecutive_min_pay"
             )
    )

    df_am00 = (
        spark.table("s11_cp_cnsum.am00_h")
             .filter(F.col("ods_business_dt").between(first_date, last_date))
             .filter(F.col("prodcode") == "CC")
             .filter(F.substring(F.col("account_num"), 1, 1) == "C")
             .select(
                 F.col("gsam_appl_num").cast("bigint").alias("account_num"),
                 "ods_business_dt",
                 "am00_date_fraud_flag",
                 "am00_statf_fraud",
                 "am00_date_security_fraud_stat",
                 "am00_statc_security_fraud",
                 "am00_paid_in_full_flag",
                 "am00_statf_highly_active",
                 "am00_statf_active_since_opened",
                 "am00_inactive_flag",
                 "am00_statf_declined_reissue",
                 "am00_statc_chargeoff",
                 "am00_statf_potential_chargeoff",
                 "am00_typec_vip",
                 "am00_statc_current_overlimit",
                 "am00_statc_current_past_due"
             )
    )

    # join all three histories
    return (
        df_am04
        .unionByName(df_am02)
        .unionByName(df_am00)
        # if you have an acct_df filter, apply it here
        if acct_df is None else
        (
            df_am04.join(acct_df, "account_num", "inner")
            .unionByName(df_am02.join(acct_df, "account_num", "inner"))
            .unionByName(df_am00.join(acct_df, "account_num", "inner"))
        )
    )


def get_cc_features(
    spark: SparkSession,
    first_balance_lookup_dt: str,
    last_lookup_dt: str,
    pop_df: DataFrame
) -> DataFrame:
    """
    Produce one row per account in pop_df with the main CC features:
      - balances (current, prev, high LTD, max/min/avg)
      - delinquency recency & counts
      - NSF & late-fee counts and amounts
      - PTP broken vs. kept
      - overlimit & past-due flags
      - fraud & chargeoff flags
      - activity / VIP flags
    """
    # 1. grab raw history
    cc_hist = cc_account_history(
        spark,
        first_date=first_balance_lookup_dt,
        last_date=last_lookup_dt,
        acct_df=pop_df.select(F.col("account_num").cast("bigint"))
    )

    # 2. join back to pop
    joined = (
        pop_df.alias("pop")
        .join(cc_hist.alias("h"), F.col("pop.account_num") == F.col("h.account_num"), "left")
    )

    # 3. aggregate per account
    feats = (
        joined.groupBy("pop.account_num")
        .agg(
            # balance features
            F.max("h.am02_balance_current").alias("cc_bal_current_max"),
            F.max("h.am02_balance_prev_statement").alias("cc_bal_prev_max"),
            F.max("h.am04_balance_high_pastdue").alias("cc_high_bal_pastdue_max"),

            F.avg("h.am02_balance_current").alias("cc_bal_current_avg"),
            F.avg("h.am02_balance_prev_statement").alias("cc_bal_prev_avg"),

            # delinquency recency & count
            F.max("h.am04_date_most_recent_pd").alias("cc_date_last_pd"),
            (F.datediff(F.lit(last_lookup_dt), F.max("h.am04_date_most_recent_pd")))
                .alias("cc_days_since_last_pd"),
            F.sum(F.when(F.col("h.am04_cons_days_pastdue") > 0, 1).otherwise(0))
                .alias("cc_pastdue_event_count"),

            # NSF & late-fee
            F.sum("h.am02_num_nsf_payments_ltd").alias("cc_nsf_count"),
            F.max("h.am02_amt_last_nsf_payment").alias("cc_amt_last_nsf"),
            F.sum("h.am02_num_lte_fee_since_lst_cur").alias("cc_latefee_count"),

            # PTP behavior
            F.sum("h.am02_num_ptp_broken_ltd").alias("cc_ptp_broken_count"),
            F.sum("h.am02_amt_ptp_broken_ltd").alias("cc_ptp_broken_amt"),
            F.sum("h.am02_num_ptp_kept_ltd").alias("cc_ptp_kept_count"),

            # overlimit & past-due flags (nullâ†’0 + flag)
            F.coalesce(F.max("h.am00_statc_current_past_due"), F.lit(0))
                .alias("cc_past_due_amt"),
            F.when(F.max("h.am00_statc_current_past_due").isNull(), 0).otherwise(1)
                .alias("cc_past_due_flag"),

            F.when(F.max("h.am00_statc_current_overlimit") == "Y", 1).otherwise(0)
                .alias("cc_overlimit_flag"),

            # fraud & chargeoff
            F.when(F.max("h.am00_statf_fraud") == "Y", 1).otherwise(0)
                .alias("cc_fraud_flag"),
            F.when(F.max("h.am00_statf_potential_chargeoff") == "Y", 1).otherwise(0)
                .alias("cc_potential_chargeoff_flag"),

            # activity / VIP
            F.when(F.max("h.am00_statf_highly_active") == "Y", 1).otherwise(0)
                .alias("cc_highly_active_flag"),
            F.when(F.max("h.am00_statf_active_since_opened") == "Y", 1).otherwise(0)
                .alias("cc_ever_active_flag"),
            F.when(F.max("h.am00_typec_vip") == "Y", 1).otherwise(0)
                .alias("cc_vip_flag")
        )
    )

    return feats















WITH rf_closed AS (
  SELECT
    LPAD(default.decrypt(rfact_acct), 18, '0')    AS account_num,
    ods_business_dt,
    rfact_dt_closed
  FROM s11_rf.rfsactu_h
  WHERE rfact_dt_closed IS NOT NULL
),
mg_closed AS (
  SELECT
    LPAD(default.decrypt(loan_num), 18, '0')      AS account_num,
    ods_business_dt,
    delq_payment_count
  FROM s11_mg.master_all_h
  WHERE delq_payment_count IS NOT NULL
)

SELECT
  c.account_num,
  c.rfact_dt_closed,
  c.ods_business_dt    AS rf_business_dt,
  m.delq_payment_count,
  m.ods_business_dt    AS mg_business_dt
FROM rf_closed AS c
LEFT JOIN mg_closed AS m
  ON m.account_num     = c.account_num
 AND m.ods_business_dt = c.ods_business_dt
;
